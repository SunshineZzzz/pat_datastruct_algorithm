* [什么是树](#什么是树)
	* [树的特征](#树的特征)
	* [基本术语](#基本术语)
* [树的表示](#树的表示)
* [二叉树的定义](#二叉树的定义)
	* [二叉树具有五种基本形态](#二叉树具有五种基本形态)
	* [特殊二叉树](#特殊二叉树)
	* [重要性质](#重要性质)
	* [二叉树的遍历](#二叉树的遍历)
	* [二叉树的非递归遍历](#二叉树的非递归遍历)
	* [二叉树的层次遍历](#二叉树的层次遍历)
	* [输出叶子结点](#输出叶子结点)
	* [树的高度](#树的高度)
	* [由两种遍历序列确定二叉树](#由两种遍历序列确定二叉树)
* [抽象数据类型定义](#抽象数据类型定义)
* [顺序存储结构](#顺序存储结构)
* [链式存储](#链式存储)
* [树的同构](#树的同构)
* [相关代码](#相关代码)

# 什么是树
树(Tree)：n(n≥0)个结点构成的有限集合，当n=0时，称为空树。

## 树的特征
对于任一棵非空树(n＞0)，它具备以下特征：
* 树中有个称为“根(Root)”的特殊结点，用r表示；
* 其余结点可分为m(m>0)个互不相交的有限集T1,T2,…,Tm，其中每个集合本身又是一棵树，称为原来树的"子树(SubTree)"；
* 子树是不相交的；
* 除根结点外，每个结点有且仅有一个父结点；
* 一棵N个结点的树有N-1条边。

## 基本术语
* 结点的度(Degree)：结点的子树个数；
* 树的度：树的所有结点中最大的度数；
* 叶结点(Leaf)：度为 0 的结点；
* 父结点(Parent)：有子树的结点是其子树的根结点的父结点；
* 子结点(Child)：若A结点是B结点的父结点，则称B结点是A结点的子结点，也称孩子结点；
* 兄弟结点(Sibling)：具有同一父结点的各个结点彼此是兄弟结点；
* 路径：从结点n1到nk的路径为一个结点序列n1,n2,…,nk，ni是ni+1的父结点；
* 路径长度：路径所包含边的个数；
* 祖先结点(Ancestor)：沿树根到某一结点路径上的所有结点都是这个结点的祖先结点；
* 子孙结点(Descendant)：某一结点的子树中的所有结点是这个结点的子孙；
* 结点的层次(Level)：规定根结点在1层，其他任一结点的层数是其父结点的层数加一；
* 树的深度(Depth)：树中所有结点中的最大层次是这棵树的深度。

# 树的表示
![树的表示1](../img/tree_show1.jpg)

**有没有更好的表示方法？**
**儿子-兄弟表示法**

![树的表示2](../img/tree_show2.jpg)

首先树上的每个结点是统一的，就是两个指针域，一个叫FirstChild, 一个叫NextSibling，第一个指针指向的是它的第一个儿子，右边的指针是指向的下一个兄弟，所有的结点都以这种方式来指向儿子和兄弟，这样就可以把整个树的结点串起来

![树的表示3](../img/tree_show3.jpg)

这样的表现方法有这样几个优点，一个是树当中的结构是统一的，都是两个指针域，同时空间浪费也不大，n个结点是2n个指针域，其中有n-1条边，所以意味着有n-1域是非空的，真正空的域是n+1,所以这种方法就是所说的儿子兄弟表示法，就是把一般的树变成结构上面比较一致的，都是两个指针的，这样的一种表示方法。

我们把这样的一种表示方法旋转45°

![树的表示4](../img/tree_show4.jpg)

这个时候右边看到的就是一棵树，这个树的特点是每一个结点都有两个指针，一个指向左边，一个指向右边，每个结点最多是两个儿子，这种树叫二叉树，二叉树就是度为2的一种树，就是每个结点的指针最多是两个，所以一般的树都可以用儿子兄弟这样的一种表示方法把它用二叉树这种形式来实现，二叉树链表的形式来实现，所以我们想研究一般树的表示跟操作的实现，最核心的最基础的，如果我们搞清楚了二叉树是怎么表示，怎么实现的，实际上就解决了一般树的许多问题。

# 二叉树的定义
二叉树T：一个有穷的结点集合。
这个集合可以为空
若不为空，则它是由**根结点**和称为其**左子树** 和**右子树**的两个不想交的二叉树组成。

## 二叉树具有五种基本形态

![二叉树图1](../img/binary_tree1.jpg)

1. 空树
2. 只有一个结点
3. 有一个结点，有左子树，但右子树是空的
4. 有一个结点，有右子树，但左子树是空的
5. 左右两边都不空

## 特殊二叉树

* 斜二叉树(Skewed Binary Tree)

![二叉树图2](../img/binary_tree2.jpg)

* 完美二叉树(Perfect Binary Tree)/满二叉树(Full Binary Tree)

![二叉树图3](../img/binary_tree3.jpg)

* 完全二叉树(Complete Binary Tree)
有n个结点的二叉树，对树中结点按从上至下，从左到右顺序进行编号，编号为i(1<=i<=n)结点与满二叉树中编号为i结点在二叉树中位置相同

![二叉树4](../img/binary_tree4.jpg)

![二叉树5](../img/binary_tree5.jpg)

## 重要性质

![二叉树6](../img/binary_tree6.jpg)

* 对任何非空二叉树T，若n0表示叶结点的个数，n2是度为2的非叶结点个数，那么两者满足关系 **n0=n2+1**。如何证明 n0 = n2 + 1？从边的角度来考虑这个问题，对于一棵树，我们来观察每个节点，每个节点往上看都有一条边，除了根结点没有边之外，每个结点都有一条边而且只有一条边，所以说从这个角度来看，边的总数是多少，是不是等于总的结点数减1，也就是n0 + n1 + n2 -1，这是我们总的结点数，减去1就是我们的边数，我们往下看，每个结点有的有一条边，有的两条边，有的什么边都没有，也就是说不同类型的结点对往下面的贡献是不一样的，n0的结点，没有儿子的结点，对往下的边的贡献数是等于0 x n0，n1这种结点是有一条往下边的，所以对边的贡献总数1 x n1，同样道理，我们有n2个结点，它往下有两条边，所以对边的贡献总数2 x n2，所以不管往上看往下看得出来的边的总数都是一样的，所以可以得到一个等式n0 + n1 + n2 -1 = 0 x n0 + 1 x n1 + 2 x n2，结论就可以证明出来了n0 = n2 + 1。

## 二叉树的遍历

二叉树的遍历最主要的有四种形式，先序遍历，中序遍历，后序遍历，层次遍历这四种形式，首先来讲讲先序遍历。

**先序遍历**

遍历过程为：
1. 访问根结点；
2. 先序遍历其左子树；
3. 先序遍历其右子树。

这样的一种遍历过程它实际上的话也是一种递归，要先去遍历这个树，就变成递归的遍历左子树和递归的遍历右子树，所以我们很自然的想到了用递归程序来实现。

![二叉树遍历1](../img/binary_tree_traversal1.jpg)

A (B D F E) (C G H I ) 先是根，然后对左边递归，然后再对右边递归
先序遍历=> A B D F E C G H I

**中序遍历**

遍历过程为：
1. 中序遍历其左子树；
2. 访问根结点；
3. 中序遍历其右子树。

![二叉树遍历2](../img/binary_tree_traversal2.jpg)

（D B E F) A (G H C I)
中序遍历 => D B E F A G H C I

**后序遍历**

遍历过程为：
1. 后序遍历其左子树；
2. 后序遍历其右子树；
3. 访问根结点。

![二叉树遍历3](../img/binary_tree_traversal3.jpg)

![二叉树遍历4](../img/binary_tree_traversal4.jpg)

我们这条路径是怎么画出来的，我们建立的基础是递归，是在递归的基础上面，我们根据递归的一些原理，一些规则，我们知道是这样的一个执行过程，实际上递归的事情是用堆栈的，后面会讲怎么借助堆栈把递归变成非递归。

## 二叉树的非递归遍历

递归根本的实现方法还是用堆栈，所以接下来想讲的一件事情是有没有可能直接用堆栈来实现，不用递归，所以这里我们举一个例子。

**中序遍历非递归遍历算法**

**非递归算法实现的基本思路：使用堆栈**

![二叉树遍历5](../img/binary_tree_traversal5.jpg)

**中序遍历非递归遍历算法**

遇到一个结点，就把它压栈，并去遍历它的左子树；
当左子树遍历结束后，从栈顶弹出这个结点并访问它；
然后按其右指针再去中序遍历该结点的右子树。

```
void InOrderTraversal(BinTree BT){
	BinTree T = BT;
	Stack S = CreateStack(MaxSize);  /*创建并初始化堆栈S*/
	while(T || !IsEmpty(S)){
		while(T){  /*一直向左并将沿途结点压入堆栈*/
			Push(S, T);  // 第一次
			T = T->Left;
		}
		if (!IsEmpty(S)){
			T = Pop(S);  /*结点弹出堆栈*/  // 第二次
			printf("%5d", T->Data);  /*（访问）打印结点*/
			T = T->Right;  /*转向右子树*/
		}
	}
}
```

## 二叉树的层次遍历

**二叉树遍历的核心问题：二维结构的线性化**

**从结点访问其左，右儿子结点**

**访问左儿子后，右儿子结点怎么办？**

**需要一个存储结构保存暂时不访问的结点**

**存储结构：堆栈，队列**

**队列实现：遍历从根结点开始，首先将根结点入队，然后开始执行循环：结点出队，访问该结点，其左右儿子入队**

下面我们来看这样的一个例子，在这个例子里面我们用一个队列对整个过程进行访问，我们的方法是这样的

![二叉树遍历6](../img/binary_tree_traversal6.jpg)

首先从根结点开始，把A放到队列里去，接下来就开始做循环了，每次循环做什么？三件事情，从队列里面抛出一个元素，print出来，然后把左右儿子放进去，所以这个A就是我们遍历的一个结果了。

![二叉树遍历7](../img/binary_tree_traversal7.jpg)

然后再循环，又从队列里面抛出第一个元素，就是B,把B print出来，输出，然后把它的左右儿子D,F放到队列里面去

![二叉树遍历8](../img/binary_tree_traversal8.jpg)

再把C从队列里抛出来，把它的左右儿子放进去

![二叉树遍历9](../img/binary_tree_traversal9.jpg)

D抛出来，左右儿子放进去，D没有左右儿子了，这个就没有元素要放到队列里面去了，进一步做这个循环，队列里面再抛出一个元素F,再把左右儿子放进去，现在只有左儿子E

![二叉树遍历10](../img/binary_tree_traversal10.jpg)

然后再从队列里抛出G,再左右儿子放进去，就这样一个个做，最后得到结果。

![二叉树遍历11](../img/binary_tree_traversal11.jpg)

这样的话，我们就把树这样的二维结构线性化，变成一个线性序列，这个序列有什么特征？

这个序列的特征是一层一层访问的。

**层序基本过程：先根结点入队，然后：**

**1.从队列中取出一个元素；**

**2.访问该元素所指结点；**

**3.若该元素所指结点的左，右孩子结点非空，则将其左，右孩子的指针顺序入队。**

```
void LevelOrderTraversal(BinTree BT){
	Queue Q; BinTree T;
	if (!BT) return;  /*若是空树则直接返回*/
	Q = CreateQueue(MaxSize);  /*创建并初始化队列Q*/
	AddQ(Q, BT);
	while (!IsEmptyQ(Q)){
		T = DeleteQ(Q);
		printf("%d\n", T->Data);  /*访问取出队列的结点*/
		if (T->Left) AddQ(Q, T->Left);
		if (T->Right) AddQ(Q, T->Right);
	}
}
```

## 输出叶子结点
在二叉树的遍历算法中增加检测结点的"左右子树是否都为空"。
```
void PreOrderPrintLeaves(BinTree BT){
	if (BT){
		if(!BT->Left && !BT->Right)
			printf("%d ", BT->Data);
		PreOrderPrintLeaves(BT->Left);
		PreOrderPrintLeaves(BT->Right);
	}
}
```
## 树的高度

```
int PostOrderGetHeight(BinTree BT){
    int HL, HR, MaxH;
    if(BT){
        HL = PostOrderGetHeight(BT->Left);  /*求左子树的深度*/
        HR = PostOrderGetHeight(BT->Right); /*求右子树的深度*/
        MaxH = (HL > HR) ? HL : HR;  /*取左右子树较大的深度*/
        return (MaxH + 1);  /*返回树的深度*/
    }
    else return 0;  /*空树深度为0*/
}
```

## 由两种遍历序列确定二叉树
![二叉树遍历12](../img/binary_tree_traversal12.jpg)

![二叉树遍历13](../img/binary_tree_traversal13.jpg)

![二叉树遍历14](../img/binary_tree_traversal14.jpg)

![二叉树遍历15](../img/binary_tree_traversal15.jpg)

# 抽象数据类型定义

* 类型名称：二叉树
* 数据对象集：一个有穷的结点集合，若不为空，则由根结点和其左、右二叉子树组成
* 操作集：BT∈BinTree，元素为Item
* 主要操作有：
* Boolean IsEmpty(BinTree BT)：判别 BT 是否为空
* void Traversal(BinTree BT)：遍历，按某顺序访问每个结点
* BinTree CreatBinTree()：创建一个二叉树
* 常用的遍历方法有：
* void PreOrderTraversal(BinTree BT)：先序——根、左子树、右子树
* void InOrderTraversal(BinTree BT)：中序——左子树、根、右子树
* void PostOrderTraversal(BinTree BT)：后序——左子树、右子树、根
* void LevelOrderTraversal(BinTree BT)：层次遍历，从上到下、从左到右

# 顺序存储结构
按从上至下、从左到右顺序存储 n 个结点的完全二叉树的结点父子关系：
* 非根结点(序号i>1)的父结点的序号是i/2(向下取整)；
* 结点(序号为i)的左孩子结点的序号是2i(若2i≤n)，否则没有左孩子；
* 结点(序号为i)的右孩子结点的序号是2i+1(若2i+1≤n)，否则没有右孩子。

![二叉树7](../img/binary_tree7.jpg)

![二叉树8](../img/binary_tree8.jpg)

![二叉树9](../img/binary_tree9.jpg)

- [x] [树的顺序存储结构实现](./Arr_tree.cc)

# 链式存储

![二叉树10](../img/binary_tree10.jpg)

- [x] [树的链式存储结构实现](./Tree.cc)

# 树的同构
给定两棵树T1和T2。如果T1可以通过若干次左右孩子互换就变成T2，则我们称两颗树是"同构"的。

![树的同构1](../img/tree_isomorphic1.jpg)

![树的同构2](../img/tree_isomorphic2.jpg)

结构数组表示二叉树：静态链表

我们基本的存储是用数组，把我们所需要的结点信息存储在数组里面，但是左右儿子用类似链表的这种方法来表示，有一个数据来指示左儿子在哪里，右儿子在哪里，物理上的存储是数组，但是它的思想是一种链表的思想，所以这种链表我们称为静态链表。

![树的同构3](../img/tree_isomorphic3.jpg)

比方说这样的一个二叉树，四个结点，怎么用结构数组来表示呢？那么一种表示方法是表示成这样：

![树的同构4](..\img\tree_isomorphic4.jpg)

这是一个数组，数组里的每个分量是个结构，也就代表了大家看到的每一列

![树的同构5](../img/tree_isomorphic5.jpg)

判别根的一个很有效的方法，看看有没有谁没指向它，没人指向它，那个结点就是根。

我们先想办法把根找到，找到根了整个树就出来了
观察输入，输入是 **值** **左儿子** **右儿子**，根结点不会作为别的结点的儿子结点出现，即输入的 0 ~ N-1 个结点中，没有在左右儿子结点位置出现过的就是根结点。

找到根结点，考虑如何判断是否同构，所谓"同构"就是儿子结点还是儿子结点，不变，只是左儿子右儿子可以互换位置。
所以设定规则如下：
1.如果结点都是空，返回 true
2.如果只有某一个结点为空，返回 false
3.如果结点值不同，返回 false
4.

# 相关代码

- [x] [顺序查找实现](./Sequential_search.cc)