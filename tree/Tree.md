* [什么是树](#什么是树)
	* [树的特征](#树的特征)
	* [基本术语](#基本术语)
* [树的表示](#树的表示)
* [二叉树的定义](#二叉树的定义)
	* [二叉树具有五种基本形态](#二叉树具有五种基本形态)
	* [特殊二叉树](#特殊二叉树)
* [重要性质](#重要性质)
* [抽象数据类型定义](#抽象数据类型定义)
* [顺序存储结构](#顺序存储结构)
* [链式存储](#链式存储)
* [相关代码](#相关代码)

# 什么是树
树(Tree)：n(n≥0)个结点构成的有限集合，当n=0时，称为空树。

## 树的特征
对于任一棵非空树(n＞0)，它具备以下特征：
* 树中有个称为“根(Root)”的特殊结点，用r表示；
* 其余结点可分为m(m>0)个互不相交的有限集T1,T2,…,Tm,其中每个集合本身又是一棵树，称为原来树的"子树(SubTree)"；
* 子树是不相交的；
* 除根结点外，每个结点有且仅有一个父结点；
* 一棵N个结点的树有N-1条边。

## 基本术语
* 结点的度(Degree)：结点的子树个数；
* 树的度：树的所有结点中最大的度数；
* 叶结点(Leaf)：度为 0 的结点；
* 父结点(Parent)：有子树的结点是其子树的根结点的父结点；
* 子结点(Child)：若A结点是B结点的父结点，则称B结点是A结点的子结点，也称孩子结点；
* 兄弟结点(Sibling)：具有同一父结点的各个结点彼此是兄弟结点；
* 路径：从结点n1到nk的路径为一个结点序列n1,n2,…,nk,ni是ni+1的父结点；
* 路径长度：路径所包含边的个数；
* 祖先结点(Ancestor)：沿树根到某一结点路径上的所有结点都是这个结点的祖先结点；
* 子孙结点(Descendant)：某一结点的子树中的所有结点是这个结点的子孙；
* 结点的层次(Level)：规定根结点在1层，其他任一结点的层数是其父结点的层数加一；
* 树的深度(Depth)：树中所有结点中的最大层次是这棵树的深度。

# 树的表示
![树的表示1](../img/tree_show1.jpg)

**有没有更好的表示方法？**
**儿子-兄弟表示法**

![树的表示2](../img/tree_show2.jpg)

首先树上的每个结点是统一的，就是两个指针域，一个叫FirstChild, 一个叫NextSibling，第一个指针指向的是它的第一个儿子，右边的指针是指向的下一个兄弟，所有的结点都以这种方式来指向儿子和兄弟，这样就可以把整个树的结点串起来

![树的表示3](../img/tree_show3.jpg)

这样的表现方法有这样几个优点，一个是树当中的结构是统一的，都是两个指针域，同时空间浪费也不大，n个结点是2n个指针域，其中有n-1条边，所以意味着有n-1域是非空的，真正空的域是n+1,所以这种方法就是所说的儿子兄弟表示法，就是把一般的树变成结构上面比较一致的，都是两个指针的，这样的一种表示方法。

我们把这样的一种表示方法旋转45°

![树的表示4](../img/tree_show4.jpg)

这个时候右边看到的就是一棵树，这个树的特点是每一个结点都有两个指针，一个指向左边，一个指向右边，每个结点最多是两个儿子，这种树叫二叉树，二叉树就是度为2的一种树，就是每个结点的指针最多是两个，所以一般的树都可以用儿子兄弟这样的一种表示方法把它用二叉树这种形式来实现，二叉树链表的形式来实现，所以我们想研究一般树的表示跟操作的实现，最核心的最基础的，如果我们搞清楚了二叉树是怎么表示，怎么实现的，实际上就解决了一般树的许多问题。

# 二叉树的定义
二叉树T：一个有穷的结点集合。
这个集合可以为空
若不为空，则它是由**根结点**和称为其**左子树** 和**右子树**的两个不想交的二叉树组成。

## 二叉树具有五种基本形态

![二叉树图1](../img/binary_tree1.jpg)

1.空树
2.只有一个结点
3.有一个结点，有左子树，但右子树是空的
4.有一个结点，有右子树，但左子树是空的
5.左右两边都不空

## 特殊二叉树

* 斜二叉树(Skewed Binary Tree)

![二叉树图2](../img/binary_tree2.jpg)

* 完美二叉树(Perfect Binary Tree)/满二叉树(Full Binary Tree)

![二叉树图3](../img/binary_tree3.jpg)

* 完全二叉树(Complete Binary Tree)
有n个结点的二叉树，对树中结点按从上至下，从左到右顺序进行编号，编号为i(1<=i<=n)结点与满二叉树中编号为i结点在二叉树中位置相同

![二叉树4](../img/binary_tree4.jpg)

![二叉树5](../img/binary_tree5.jpg)

# 重要性质

![二叉树6](../img/binary_tree6.jpg)

* 对任何非空二叉树T, 若n0表示叶结点的个数， n2是度为2的非叶结点个数，那么两者满足关系 **n0=n2+1**

# 抽象数据类型定义
* 类型名称：二叉树
* 数据对象集：一个有穷的结点集合，若不为空，则由根结点和其左、右二叉子树组成
* 操作集：BT∈BinTree，元素为Item
* 主要操作有：
* Boolean IsEmpty(BinTree BT)：判别 BT 是否为空
* void Traversal(BinTree BT)：遍历，按某顺序访问每个结点
* BinTree CreatBinTree()：创建一个二叉树
* 常用的遍历方法有：
* void PreOrderTraversal(BinTree BT)：先序——根、左子树、右子树
* void InOrderTraversal(BinTree BT)：中序——左子树、根、右子树
* void PostOrderTraversal(BinTree BT)：后序——左子树、右子树、根
* void LevelOrderTraversal(BinTree BT)：层次遍历，从上到下、从左到右

# 顺序存储结构
按从上至下、从左到右顺序存储 n 个结点的完全二叉树的结点父子关系：
* 非根结点(序号i>1)的父结点的序号是i/2(向下取整)；
* 结点(序号为i)的左孩子结点的序号是2i(若2i≤n)，否则没有左孩子；
* 结点(序号为i)的右孩子结点的序号是2i+1(若2i+1≤n)，否则没有右孩子。

![二叉树7](../img/binary_tree7.jpg)

![二叉树8](../img/binary_tree8.jpg)

![二叉树9](../img/binary_tree9.jpg)

- [x] [树的顺序存储结构实现](./Arr_tree.cc)

# 链式存储

![二叉树10](../img/binary_tree10.jpg)

# 相关代码
- [x] [顺序查找](./Sequential_search.cc)